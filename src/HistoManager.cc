//
// ********************************************************************
// * License and Disclaimer                                           *
// *                                                                  *
// * The  Geant4 software  is  copyright of the Copyright Holders  of *
// * the Geant4 Collaboration.  It is provided  under  the terms  and *
// * conditions of the Geant4 Software License,  included in the file *
// * LICENSE and available at  http://cern.ch/geant4/license .  These *
// * include a list of copyright holders.                             *
// *                                                                  *
// * Neither the authors of this software system, nor their employing *
// * institutes,nor the agencies providing financial support for this *
// * work  make  any representation or  warranty, express or implied, *
// * regarding  this  software system or assume any liability for its *
// * use.  Please see the license in the file  LICENSE  and URL above *
// * for the full disclaimer and the limitation of liability.         *
// *                                                                  *
// * This  code  implementation is the result of  the  scientific and *
// * technical work of the GEANT4 collaboration.                      *
// * By using,  copying,  modifying or  distributing the software (or *
// * any work based  on the software)  you  agree  to acknowledge its *
// * use  in  resulting  scientific  publications,  and indicate your *
// * acceptance of all terms of the Geant4 Software license.          *
// ********************************************************************
//
/// \file analysis/AnaEx02/src/HistoManager.cc
/// \brief Implementation of the HistoManager class
//
// $Id: HistoManager.cc 98060 2016-07-01 16:24:08Z gcosmo $
// GEANT4 tag $Name: geant4-09-04 $
//
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

// #include <TH1D.h>
// #include <TFile.h>
// #include <TTree.h>
// #include <TMath.h>
#include <CLHEP/Units/SystemOfUnits.h>
#include "G4SystemOfUnits.hh"
#include "G4PhysicalConstants.hh"

#include "HistoManager.hh"
#include "G4UnitsTable.hh"
#include "EventAction.hh"
#include "RunAction.hh"
#include "SteppingAction.hh"
#include "DetectorConstruction.hh"

#include "G4Run.hh"
#include "G4RunManager.hh"
#include "G4Event.hh"
#include "G4Step.hh"
#include "G4Track.hh"
#include "G4ProcessManager.hh"

#include "SteppingVerbose.hh"
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

HistoManager::HistoManager(DetectorConstruction *det)
    : fFactoryOn(false),
      fPrintModulo(1000000),
      fDetector(det)
{
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

HistoManager::~HistoManager()
{
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void HistoManager::BeginOfRunAction(const G4Run *aRun)
{
  G4cout << "### Run " << aRun->GetRunID() << " start." << G4endl;
  
  Book();
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void HistoManager::EndOfRunAction(const G4Run *aRun)
{
  NbOfEvents = aRun->GetNumberOfEventToBeProcessed(); 
  if (NbOfEvents == 0)
    return;
  Save();
  // for (auto it = fLevProcName.begin(); it != fLevProcName.end(); ++it)
  //     std::cout << *it<< std::endl;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void HistoManager::BeginOfEventAction(const G4Event *evt)
{
  // initialisation per event
  // fNumOfComptAtGe = 0;//在Ge中发生的康普顿次数
  // fAngle = 0.;     //经过Ge之后gamma的散射角度
  fCsIDepEng = 0.;
  fHPGeEng = 0.;
  // ftmp = 0.;
  fEeBrem = 0.;
  fEeBremO = 0.;
  pNBrem = 0;
  // fLProcName.clear();
  // pMProcNum = 0;
  // G4cout << "----------A new Event!----------" << std::endl;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void HistoManager::EndOfEventAction(const G4Event *)
{
  // Mapping physics process to a number;
  // 1. Rayl, 2. compt, 4. eBrem 8. phot 16. Scintillation
  // pProcNum = 0;
  // for (auto it = fLProcName.begin(); it != fLProcName.end(); ++it) {
  //   if (*it == "Rayl")        pProcNum += 1;
  //   else if (*it == "compt")  pProcNum += 2;
  //   else if (*it == "eBrem")  pProcNum += 4;
  //   else if (*it == "phot")   pProcNum += 8;
  //   else if (*it == "Scintillation") pProcNum += 16;
  // }
  // fill tuple
  FillTuple();
  //ShowCompteTrackStatus(fCompteTrackIDVec);
  //
  /*
  G4cout << "# of e- generated in a event is " << fNumOfe << std::endl;
  G4cout << "# of e- generated by Compton in a event is " <<
    ftmp << std::endl;
  G4cout << "----------The end of an Event----------" << std::endl;
  */
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void HistoManager::RecordStep(const G4Step *aStep)
{

  // get volume of the current step
  //
  fVolume = aStep->GetPreStepPoint()->GetTouchableHandle()->GetVolume();
  fPostVolume = aStep->GetPostStepPoint()->GetTouchableHandle()->GetVolume();
  fpostMomentum = aStep->GetPostStepPoint()->GetMomentumDirection();
  fPostKEnergy = aStep->GetPostStepPoint()->GetKineticEnergy() / keV;
  //在这一步的过程的反应
  fProcess = aStep->GetPostStepPoint()
    ->GetProcessDefinedStep()->GetProcessName();
  // G4cout << "work?" << G4endl;
  // fLvingProc = aStep->GetTrack()->GetCreatorProcess()->GetProcessName();
  // G4cout << "work?" << G4endl;
  //获得沉积下来的能量
  ftmpEnergy =
    aStep->GetTotalEnergyDeposit() / keV;

  // Get Track
  //
  aTrack = aStep->GetTrack();
  fTrackID = aTrack->GetTrackID();
  fParentID = aTrack->GetParentID();
  fParticle = aTrack->GetDefinition()->GetParticleName();
  // G4cout << "work?" << G4endl;


  // fLProcName.insert(fProcess);
  /*
  if (fVolume == fDetector->GetHPGe()
      and fPostVolume == fDetector->GetphysiWorld()) {
    // G4cout << fLvingProc << G4endl;
    if (fTrackID != 1) {
      // 记录次级粒子
      fLvingProc = aStep->GetTrack()->GetCreatorProcess()->GetProcessName();
      pSProcNum = 0;
      if (fLvingProc == "eBrem")               pSProcNum = 4;
      else if (fLvingProc == "phot")           pSProcNum = 5;
      else if (fLvingProc == "Scintillation")  pSProcNum = 6;
    }
    if (fTrackID == 1) {
      pMProcNum = 0;
    }
  }
  */

  // if (fPostVolume == fDetector->GetHPGe() and fVolume == fDetector->GetphysiWorld()) fLevProcName.insert(fParticle);

  //Record compton energy and times of compt scattring.
  // RecordGammaFinalAngle();
  //recordDepEng();
  if (fVolume == fDetector->GetCsIDetector()) {
    fCsIDepEng += ftmpEnergy;
    if (fProcess == "eBrem") fEeBrem += ftmpEnergy;
  }
  if (fVolume == fDetector->GetHPGe()) {
    fHPGeEng += ftmpEnergy;
  }

  // if (fVolume == fDetector->GetCsIDetector() and fPostVolume == fDetector->GetphysiWorld()) {
  //   if (fTrackID != 1) {
  //     fGenerator = aStep->GetTrack()->GetCreatorProcess()->GetProcessName();
  //     if (fGenerator == "eBrem" and fParticle == "gamma") {
  //       fEeBremO += fPostKEnergy;
  //       pNBrem++;
  //     }
  //   }
  // }

  // if (fVolume == fDetector->GetCsIDetector() and fPostVolume == fDetector->GetphysiWorld()) {
  //   if (fTrackID == 1) pMProcNum = 1;
  //     else {
  //       fGenerator = aStep->GetTrack()->GetCreatorProcess()->GetProcessName();
  //       if (fGenerator  == "eBrem") pMProcNum = 2;
  //       else if (fGenerator  == "eIoni") pMProcNum = 3;
  //       else if (fGenerator  == "compt") pMProcNum = 4;
  //       else if (fGenerator  == "phot") pMProcNum = 5;
  //       else G4cout << fGenerator << G4endl;
  //     }
  //   }
  }



//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void HistoManager::recordDepEng(){
  if (fVolume == fDetector->GetCsIDetector())
  {
    
    fCsIDepEng += ftmpEnergy;
    /*
      // Method faild.
    auto subParticles = aStep->GetSecondaryInCurrentStep();
    for(size_t i=0;i<subParticles->size();++i){
      auto subParticle = subParticles->at(i)->GetDefinition()->GetParticleName();
      if (subParticle == "e-"){
        fcompteTrackID = subParticles->at(i)->GetTrackID();
        G4cout << "compton ele's ID is: " << fcompteTrackID << std::endl;
      }
    }
    */
    //G4cout << "# of Compton = " << fNumOfComptAtGe << std::endl;
  }
  return;
}
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void HistoManager::RecordGammaFinalAngle(){
  //在离开Ge时获取散射角度
  if (fVolume == fDetector->GetCsIDetector()
      and fPostVolume == fDetector->GetphysiWorld()
      and fTrackID == 1 and fParentID == 0)
  {
    preX = 1; preY = 0; preZ = 0;
    postX = fpostMomentum.x();
    postY = fpostMomentum.y();
    postZ = fpostMomentum.z();
    // std::cout << postX << std::endl;

    auto up = preX * postX;
    auto down = sqrt(postX * postX + postY * postY + postZ * postZ);

    fAngle = acos(up / down) * 180 / TMath::Pi();
    fGammaFinalEnergy = fPostKEnergy;
    // 不考虑角度单多次离开Ge的动能//compton散射后粒子的能量
    // G4cout << "Gamma leaving angle is: " << fAngle << std::endl;
  }
  return;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void HistoManager::ShowProcessGenerateEle(const G4Step *aStep){
  // This Func show primary photon generate electron.
  if (fParentID == 0 && fTrackID == 1){
    auto iter = aStep->GetSecondaryInCurrentStep();
    for(size_t sub=0;sub<iter->size();sub++){
      auto subparticle=(*iter)[sub]->GetDefinition()->GetParticleName();
      if(subparticle=="e-"){
        //feBremEnergy += tmpEnergy / keV;
        fNumOfe++;
        G4cout << "A process generate an e-: " << fProcess << std::endl;
        G4cout << "Now the number of e- is: " << fNumOfe << std::endl;
      }
    }
  }
  return;
}
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void HistoManager::ShowCompteTrackStatus(std::vector<G4int> aVec){
  G4cout << "--------------CompteStatus----------------" << std::endl;
  G4cout << "# of Compt e- is: " << (int)aVec.size() << std::endl;
  G4cout << "Whose TrackID is(are) the following: " << std::endl;
  for(std::vector<G4int>::iterator it = aVec.begin();
      it != aVec.end();
      it++){
    G4cout << *it << std::endl;
  }
  G4cout<< "-----------TheEndOfCompteStatus------------" << std::endl;
  return;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void HistoManager::Book()
{
  // Creating a tree container to handle histograms and ntuples.
  // This tree is associated to an output file.
  //
  auto analysisManager = G4AnalysisManager ::Instance();
  analysisManager->SetVerboseLevel(1);
  analysisManager->SetNtupleMerging(true);

  G4String fileName = "AnaEx02";
  G4bool fRootFile = analysisManager->OpenFile(fileName);
  // fRootFile = new TFile(fileName, "RECREATE");
  if (!fRootFile)
  {
    G4cout << " HistoManager::Book :"
           << " problem creating the ROOT TFile "
           << G4endl;
    return;
  }
  fFactoryOn = true;

  analysisManager->CreateNtuple("e", "");
  analysisManager->CreateNtupleDColumn(0, "e_csi");
  analysisManager->CreateNtupleDColumn(0, "e_hpge");
  analysisManager->FinishNtuple(0);

  // analysisManager->CreateNtuple("eBrem", "");
  // analysisManager->CreateNtupleDColumn(1, "e_brem");
  // analysisManager->CreateNtupleDColumn(1, "e_brem_o");
  // analysisManager->CreateNtupleIColumn(1, "n_brem");
  // analysisManager->FinishNtuple(1);

  G4cout << "\n----> Output file is open in " << fileName << G4endl;
}
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......


void HistoManager::FillTuple(){
  //fill ntuple
  //
  G4AnalysisManager *analysisManager = G4AnalysisManager::Instance();

  if (fCsIDepEng != 0 and fHPGeEng != 0){
    //and fHPGeEng != 0
    analysisManager->FillNtupleDColumn(0, 0, fCsIDepEng);
    analysisManager->FillNtupleDColumn(0, 1, fHPGeEng);
    analysisManager->AddNtupleRow(0);
  }
  // if (fEeBrem != 0){
  //   analysisManager->FillNtupleDColumn(1, 0, fEeBrem);
  //   analysisManager->FillNtupleDColumn(1, 1, fEeBremO);
  //   analysisManager->FillNtupleIColumn(1, 2, pNBrem);
  //   analysisManager->AddNtupleRow(1);
  // }
  return;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void HistoManager::Save() {
  if (!fFactoryOn)
    return;
  auto analysisManager = G4AnalysisManager ::Instance();
  analysisManager->Write();
  analysisManager->CloseFile(); // and closing the tree (and the file)

  G4cout << "\n----> Histograms and ntuples are saved\n"
         << G4endl;
}
